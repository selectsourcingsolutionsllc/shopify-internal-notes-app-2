RAILWAY DEPLOYMENT TROUBLESHOOTING GUIDE
=========================================
Complete breakdown of all 23 critical fixes for deploying Shopify Internal Notes App to Railway

Author: Claude Code & User
Date: October 8, 2025
Project: shopify-internal-notes-app-2


═══════════════════════════════════════════════════════════════════════════════

ISSUE #1: Removed NODE_ENV from build
──────────────────────────────────────
THE PROBLEM:
Build script had `NODE_ENV=production remix build` which is Windows-style syntax.

WHY IT WAS STUBBORN:
- Works fine on Windows/Mac locally
- Railway uses Linux containers which don't support this syntax
- Build would fail with syntax errors on Railway

HOW IT WAS RESOLVED:
- Removed `NODE_ENV=production` from package.json build script
- Railway automatically sets NODE_ENV=production in production environments
- Changed from: `"build": "NODE_ENV=production remix build"`
- Changed to: `"build": "remix build"`


═══════════════════════════════════════════════════════════════════════════════

ISSUE #2: Added Prisma migrate deploy
──────────────────────────────────────
THE PROBLEM:
Database tables didn't exist when app started, causing MissingSessionTableError.

WHY IT WAS STUBBORN:
- Migrations need to run AFTER DATABASE_URL is available
- Initially tried running in build phase but database wasn't connected yet
- Had to find the right timing in deployment lifecycle

HOW IT WAS RESOLVED:
- Added `npx prisma migrate deploy` to nixpacks.toml build commands
- Later moved to start command when build timing didn't work
- Eventually placed in package.json start script for reliability


═══════════════════════════════════════════════════════════════════════════════

ISSUE #3: Removed invalid workspaces configuration
───────────────────────────────────────────────────
THE PROBLEM:
package.json declared workspaces for extensions/* folders that were empty.

WHY IT WAS STUBBORN:
- npm ci would fail looking for package.json files in empty directories
- Error messages weren't clear about which workspace was missing
- Had to trace through npm install logs to find the issue

HOW IT WAS RESOLVED:
- Removed the entire workspaces configuration from package.json
- Extensions folders existed but had no package.json files
- Workspaces weren't needed for this project structure


═══════════════════════════════════════════════════════════════════════════════

ISSUE #4: Created Procfile web command
───────────────────────────────────────
THE PROBLEM:
Railway didn't know how to start the app properly.

WHY IT WAS STUBBORN:
- Without Procfile, Railway guesses the start command
- Misdetection could lead to wrong startup sequence
- Needed explicit declaration of web process type

HOW IT WAS RESOLVED:
- Created Procfile with `web: npm run start`
- Explicitly tells Railway this is a web service
- Later updated to include migration command


═══════════════════════════════════════════════════════════════════════════════

ISSUE #5: Updated Shopify package version
──────────────────────────────────────────
THE PROBLEM:
Old @shopify/shopify-app-remix version (3.0.0) used import assertions syntax that
esbuild 0.17.6 couldn't parse.

WHY IT WAS STUBBORN:
- Error message pointed to Shopify package code, not our code
- Syntax `with { type: 'json' }` is new JavaScript feature
- Required both package update AND esbuild update to work together

HOW IT WAS RESOLVED:
- Updated @shopify/shopify-app-remix from 3.0.0 to 4.0.1
- Newer version compatible with modern build tools
- Combined with esbuild 0.24.0 override to support import assertions


═══════════════════════════════════════════════════════════════════════════════

ISSUE #6: Managed remix.config.js for Remix version compatibility
──────────────────────────────────────────────────────────────────
THE PROBLEM:
Configuration file requirements changed when switching Remix versions.

WHY IT WAS STUBBORN:
- Remix 2.16 uses Vite and ignores remix.config.js
- Remix 2.7.1 uses esbuild and REQUIRES remix.config.js
- Had to understand which version needs which config file

HOW IT WAS RESOLVED:
- Initially removed remix.config.js when attempting to use Remix 2.16 with Vite
- Recreated remix.config.js when downgrading to Remix 2.7.1 (esbuild-based)
- Final state: BOTH files exist - remix.config.js (for Remix 2.7.1) AND vite.config.ts (for dev server)
- remix.config.js has serverModuleFormat: "cjs" which is critical for Railway deployment


═══════════════════════════════════════════════════════════════════════════════

ISSUE #7: Added Node 22.11.0 version
─────────────────────────────────────
THE PROBLEM:
Node.js version wasn't specified, Railway might use incompatible version.

WHY IT WAS STUBBORN:
- Different Node versions have different feature support
- Import assertions require Node 16+
- No explicit version = unpredictable behavior

HOW IT WAS RESOLVED:
- Created .node-version file with "22.11.0"
- Ensures Railway uses exact same Node version as local development
- Guarantees feature compatibility across environments


═══════════════════════════════════════════════════════════════════════════════

ISSUE #8: Updated nixpacks to nodejs_22
────────────────────────────────────────
THE PROBLEM:
nixpacks.toml specified nodejs_20, but we needed nodejs_22.

WHY IT WAS STUBBORN:
- Both .node-version and nixpacks.toml control Node version
- Conflicting specifications could cause issues
- Had to align both configuration sources

HOW IT WAS RESOLVED:
- Changed nixpacks.toml from nodejs_20 to nodejs_22
- Now matches .node-version file specification
- Consistent Node version across all configs


═══════════════════════════════════════════════════════════════════════════════

ISSUE #9: Updated Vite to 6.0.0 (for dev server only)
─────────────────────────────────────────────────────
THE PROBLEM:
Needed modern Vite version for development server and tooling compatibility.

WHY IT WAS STUBBORN:
- Vite updates can break builds if not careful
- Had to ensure compatibility with Remix version
- Version conflicts between dependencies

HOW IT WAS RESOLVED:
- Updated vite to ^6.0.0 in package.json
- IMPORTANT NOTE: Remix 2.7.1 uses esbuild for production builds, NOT Vite
- Vite 6.0.0 is used ONLY for the development server (npm run dev)
- Production builds on Railway use Remix's esbuild-based compiler
- vite.config.ts configures dev server behavior, not production builds


═══════════════════════════════════════════════════════════════════════════════

ISSUE #10: Added esbuild 0.24.0 override
─────────────────────────────────────────
THE PROBLEM:
Remix was using esbuild 0.17.6 which doesn't support `with { type: 'json' }` syntax.

WHY IT WAS STUBBORN:
- esbuild was a transitive dependency (dependency of a dependency)
- npm doesn't automatically update nested dependencies
- Needed to FORCE specific version across all packages

HOW IT WAS RESOLVED:
- Added to package.json:
  "resolutions": { "esbuild": "0.24.0" }
  "overrides": { "esbuild": "0.24.0" }
- Forces ALL packages to use esbuild 0.24.0
- Overrides Remix's built-in esbuild version


═══════════════════════════════════════════════════════════════════════════════

ISSUE #11: Configured esbuild import-assertions support
─────────────────────────────────────────────────────────
THE PROBLEM:
Even with esbuild 0.24.0, import assertions needed explicit configuration.

WHY IT WAS STUBBORN:
- esbuild can parse import assertions but feature must be explicitly enabled
- Configuration syntax varies between Vite and direct esbuild usage
- Error messages didn't indicate this was a configuration issue
- Unclear where to configure esbuild settings for Remix 2.7.1

HOW IT WAS RESOLVED:
- Added esbuild configuration to vite.config.ts:
  esbuild: {
    target: 'es2022',
    supported: {
      'import-assertions': true,
    },
  }
- IMPORTANT NOTE: This config is in vite.config.ts, but Remix 2.7.1 builds use esbuild directly
- The esbuild 0.24.0 override in package.json is what actually enables import assertions in production
- vite.config.ts esbuild settings apply to development server only
- Production builds rely on esbuild override version supporting import assertions by default


═══════════════════════════════════════════════════════════════════════════════

ISSUE #12: Regenerated npm package-lock.json
─────────────────────────────────────────────
THE PROBLEM:
package-lock.json still referenced old esbuild version despite overrides.

WHY IT WAS STUBBORN:
- Railway uses package-lock.json to install exact versions
- Changing package.json doesn't auto-update lock file
- Lock file takes precedence over package.json specifications

HOW IT WAS RESOLVED:
- Ran `npm install` locally to regenerate package-lock.json
- Lock file now reflects esbuild 0.24.0 and all updated packages
- Committed and pushed new lock file to trigger Railway rebuild


═══════════════════════════════════════════════════════════════════════════════

ISSUE #13: Downgraded to Remix 2.7.1
─────────────────────────────────────
THE PROBLEM:
Remix 2.16 with Vite cannot output CommonJS server builds, only ESM.
Node.js couldn't load ESM imports from CommonJS modules.

WHY IT WAS STUBBORN:
- Remix 2.16+ uses Vite which only supports ESM server output
- serverModuleFormat option doesn't exist in Vite-based Remix
- Got error: "Named export 'Response' not found" from @remix-run/node
- This was a fundamental architecture limitation

HOW IT WAS RESOLVED:
- Downgraded all Remix packages to 2.7.1
- Remix 2.7.1 uses esbuild-based compiler (not Vite)
- Supports serverModuleFormat: 'cjs' in remix.config.js
- esbuild 0.24.0 override still works for import assertions


═══════════════════════════════════════════════════════════════════════════════

ISSUE #14: Removed type module declaration
───────────────────────────────────────────
THE PROBLEM:
package.json had "type": "module" which forced ESM mode everywhere.

WHY IT WAS STUBBORN:
- With "type": "module", Node treats all .js files as ESM
- But we needed CommonJS server build for compatibility
- Remix 2.7.1 with CJS output conflicts with ESM package type

HOW IT WAS RESOLVED:
- Removed "type": "module" from package.json
- Allows .js files to be CommonJS by default
- Server build now outputs and runs as CommonJS successfully


═══════════════════════════════════════════════════════════════════════════════

ISSUE #15: Created remix.config.js CommonJS output
───────────────────────────────────────────────────
THE PROBLEM:
Needed to configure Remix to output CommonJS server build.

WHY IT WAS STUBBORN:
- Configuration option location changed between Remix versions
- In Vite-based Remix, this option doesn't exist
- Had to use older Remix version to access this setting

HOW IT WAS RESOLVED:
- Created remix.config.js with:
  export default {
    ignoredRouteFiles: ["**/.*"],
    serverModuleFormat: "cjs",
  };
- Explicitly tells Remix to compile server as CommonJS
- Server build in build/index.js now uses require() not import


═══════════════════════════════════════════════════════════════════════════════

ISSUE #16: User added https protocol
─────────────────────────────────────
THE PROBLEM:
SHOPIFY_APP_URL environment variable was missing the "https://" protocol.

WHY IT WAS STUBBORN:
- User originally set: shopify-internal-notes-app-production.up.railway.app
- Shopify validation requires FULL URL with protocol
- Error message was vague: "Invalid appUrl configuration"

HOW IT WAS RESOLVED:
- USER went to Railway Dashboard → Variables
- USER updated SHOPIFY_APP_URL to include https://
- Changed to: https://shopify-internal-notes-app-production.up.railway.app
- App validation passed after this change


═══════════════════════════════════════════════════════════════════════════════

ISSUE #17: User fixed empty DATABASE_URL
─────────────────────────────────────────
THE PROBLEM:
DATABASE_URL environment variable was set to empty string "".

WHY IT WAS STUBBORN:
- Variable existed but had no value
- Caused confusing error about "empty string" in Prisma validation
- User had TWO database-related variables: DATABASE_URL and DATABASE_PUBLIC_URL
- Not clear which one to use or why one was empty

HOW IT WAS RESOLVED:
- USER deleted the empty DATABASE_URL variable in Railway Dashboard
- Railway automatically regenerated it with correct PostgreSQL connection string
- DATABASE_PUBLIC_URL is for external access, DATABASE_URL is for internal
- Prisma could now connect to database successfully


═══════════════════════════════════════════════════════════════════════════════

ISSUE #18: User added PORT=3000 variable
─────────────────────────────────────────
THE PROBLEM:
Railway tried to bind app to specific IP (66.33.22.190:8080) but got EADDRNOTAVAIL.

WHY IT WAS STUBBORN:
- remix-serve expected PORT environment variable but it didn't exist
- Railway's public networking was set to port 3000
- Without PORT variable, remix-serve used wrong port/binding
- Error showed mysterious IP address not in our code

HOW IT WAS RESOLVED:
- USER went to Railway Dashboard → Variables
- USER added PORT=3000 environment variable
- Tells the app which port to listen on
- Later replaced remix-serve with Express to fix binding issue fully


═══════════════════════════════════════════════════════════════════════════════

ISSUE #19: Created Express 0.0.0.0 server
──────────────────────────────────────────
THE PROBLEM:
remix-serve couldn't bind to 0.0.0.0 (all network interfaces).
Railway needs apps to bind to 0.0.0.0, not localhost or specific IPs.

WHY IT WAS STUBBORN:
- remix-serve is designed for local development, not production
- It doesn't support binding to 0.0.0.0
- Even with PORT variable, got EADDRNOTAVAIL errors
- remix-serve tried binding to Railway's internal IP which failed

HOW IT WAS RESOLVED:
- Created server.js with Express:
  import { createRequestHandler } from "@remix-run/express";
  import express from "express";

  app.listen(port, "0.0.0.0", () => {...});
- Express explicitly binds to 0.0.0.0 (all interfaces)
- Added express and @remix-run/express dependencies
- Updated start script to use `node server.js` instead of remix-serve


═══════════════════════════════════════════════════════════════════════════════

ISSUE #20: Added migration to start
────────────────────────────────────
THE PROBLEM:
Database tables didn't exist when app started, causing crashes.

WHY IT WAS STUBBORN:
- Migrations in build phase ran before DATABASE_URL was available
- Multiple attempts to place migration command in right location
- Needed migrations to run AFTER database connection, BEFORE app start

HOW IT WAS RESOLVED:
- Moved `npx prisma migrate deploy` from build phase to start phase
- Updated nixpacks.toml start command to include migration
- Migrations now run when DATABASE_URL is guaranteed to exist
- Tables created successfully before app initialization


═══════════════════════════════════════════════════════════════════════════════

ISSUE #21: Updated Procfile migration command
──────────────────────────────────────────────
THE PROBLEM:
Procfile changes weren't being applied - Railway still ran old command.

WHY IT WAS STUBBORN:
- Updated Procfile to: `web: npx prisma migrate deploy && npm run start`
- Logs showed it was STILL running just `npm run start`
- Procfile seemed to be ignored or cached
- Railway calls `npm run start` which looks in package.json, not Procfile

HOW IT WAS RESOLVED:
- Initially tried updating Procfile - didn't work
- Realized Railway was executing `npm run start` from package.json
- package.json start script takes precedence over Procfile
- Had to update package.json start script directly (see Issue #22)


═══════════════════════════════════════════════════════════════════════════════

ISSUE #22: Updated package.json start script
─────────────────────────────────────────────
THE PROBLEM:
Migration command in Procfile and nixpacks.toml wasn't actually running.

WHY IT WAS STUBBORN:
- **ISSUE #1:** Added migration to nixpacks.toml start command
  → Procfile overrode it with just `web: npm run start`

- **ISSUE #2:** Updated Procfile with migration command
  → Railway still ran old command, logs showed no migration
  → Root cause: Railway calls `npm run start` which executes package.json script
  → package.json had: "start": "node server.js" (no migration!)

- **THE BREAKTHROUGH:** Realized npm script overrides Procfile

HOW IT WAS RESOLVED:
- Updated package.json start script directly:
  "start": "prisma migrate deploy && node server.js"
- Now when Railway runs `npm run start`, it executes migration THEN server
- Logs finally showed migration running and tables being created
- This was the FINAL piece that made migrations actually work


═══════════════════════════════════════════════════════════════════════════════

ISSUE #23: Added /health database endpoint
───────────────────────────────────────────
THE PROBLEM:
Railway healthcheck failed because root path "/" required Shopify authentication.

WHY IT WAS STUBBORN:
- Railway checked "/" which redirected to Shopify OAuth
- Healthcheck got redirect (302) not success (200)
- Deployment marked as unhealthy and kept restarting
- Needed public endpoint that returns 200 without auth

HOW IT WAS RESOLVED:
- Created app/routes/health.tsx:
  - Runs `SELECT 1` database query to verify connection
  - Returns 200 + JSON if healthy
  - Returns 503 + error details if database down
- USER configured Railway healthcheck path to "/health"
- Railway now checks /health which returns 200
- Healthcheck passes, deployment marked as healthy


═══════════════════════════════════════════════════════════════════════════════

ISSUE #24: User configured /health path
────────────────────────────────────────
THE PROBLEM:
Railway was still checking "/" even though /health endpoint existed.

WHY IT WAS STUBBORN:
- Created /health endpoint but Railway didn't know to use it
- Initial deployment still checked "/" and failed
- Healthcheck setting needed to be explicitly configured
- Setting didn't auto-update for existing deployments

HOW IT WAS RESOLVED:
- USER went to Railway Dashboard → Service Settings
- USER scrolled to "Healthcheck Path" field
- USER entered "/health" and saved
- Triggered new deployment to apply new healthcheck setting
- Railway now checks /health instead of /
- Healthcheck passes, deployment successful! 🎉


═══════════════════════════════════════════════════════════════════════════════

SUMMARY OF KEY INSIGHTS
========================

1. LAYERED CONFIGURATIONS ARE TRICKY
   - Railway prioritizes: Procfile > nixpacks.toml > auto-detection
   - But npm scripts in package.json override Procfile commands!
   - Always update the ACTUAL execution path, not just config files

2. LOCK FILES MATTER
   - package-lock.json overrides package.json specifications
   - Must regenerate lock file after changing dependencies
   - Railway uses lock file for exact version installation

3. ENVIRONMENT VARIABLES NEED EXPLICIT SETUP
   - Railway doesn't auto-provide all needed variables
   - DATABASE_URL from Postgres service must be connected manually
   - PORT must be explicitly set, not assumed

4. REMIX VERSION MATTERS FOR MODULE FORMATS
   - Remix 2.16+ (Vite) only supports ESM server builds
   - Remix 2.7.1 (esbuild) supports CommonJS server builds
   - Choose version based on deployment requirements

5. HEALTHCHECKS NEED PUBLIC ENDPOINTS
   - Root paths often require authentication
   - Create dedicated /health endpoint without auth
   - Verify actual application health (database, services)

6. MIGRATION TIMING IS CRITICAL
   - Build phase: DATABASE_URL might not exist yet
   - Start phase: DATABASE_URL guaranteed to exist
   - Run migrations in start phase, before app initialization

7. NETWORK BINDING FOR CONTAINERS
   - Local dev tools (remix-serve) bind to localhost
   - Production containers need 0.0.0.0 binding
   - Use production-ready servers (Express, custom)


═══════════════════════════════════════════════════════════════════════════════

FINAL DEPLOYMENT ARCHITECTURE
==============================

Build Phase (nixpacks.toml):
  1. Install Node.js 22
  2. Run npm ci (install dependencies)
  3. Generate Prisma client
  4. Build Remix app (CommonJS output)

Start Phase (package.json start script):
  1. Run prisma migrate deploy (create/update tables)
  2. Start Express server on 0.0.0.0:3000
  3. Express serves Remix app via @remix-run/express

Healthcheck:
  - Railway checks /health endpoint
  - Returns 200 if database connected
  - Returns 503 if database unavailable

Environment Variables (Railway Dashboard):
  - DATABASE_URL: PostgreSQL connection (auto from Railway Postgres)
  - PORT: 3000 (manually set)
  - SHOPIFY_APP_URL: https://shopify-internal-notes-app-production.up.railway.app
  - SCOPES: (Shopify app scopes)
  - SHOPIFY_API_KEY: (from Shopify Partner Dashboard)
  - SHOPIFY_API_SECRET: (from Shopify Partner Dashboard)


═══════════════════════════════════════════════════════════════════════════════

LESSONS FOR FUTURE DEPLOYMENTS
===============================

1. Start with healthcheck endpoint FIRST
   - Create /health before deploying
   - Configure healthcheck path immediately
   - Prevents endless restart loops

2. Verify environment variables BEFORE deploying
   - Check DATABASE_URL is populated
   - Confirm PORT is set correctly
   - Validate all URLs have https:// protocol

3. Test migration timing locally
   - Run with same environment setup as production
   - Verify DATABASE_URL availability during startup
   - Confirm tables created before app starts

4. Use production-ready server from start
   - Don't rely on dev servers (remix-serve)
   - Configure Express with 0.0.0.0 binding
   - Test containerized deployment locally with Docker

5. Keep package-lock.json in sync
   - Regenerate after every dependency change
   - Commit lock file immediately
   - Never .gitignore the lock file

6. Document environment variable requirements
   - List all required variables
   - Specify which are auto-provided vs manual
   - Note correct format for each (URLs, ports, etc.)


═══════════════════════════════════════════════════════════════════════════════

END OF DEPLOYMENT SOLUTIONS DOCUMENT
Generated: October 8, 2025
Status: ✅ DEPLOYMENT SUCCESSFUL
URL: https://shopify-internal-notes-app-production.up.railway.app
═══════════════════════════════════════════════════════════════════════════════
